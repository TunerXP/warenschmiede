<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Warenschmiede Breakout (Test)</title>
  <style>
    :root {
      --ws-bg: #f3f6fb;
      --ws-card: #ffffff;
      --ws-accent: #2cc5f2;
      --ws-underline: #86c5ff;
      --ws-letter: #1fb0e5;
      --ws-shadow: rgba(0, 0, 0, 0.08);
      --ws-dark: #0b1f33;
      --ws-orange: #f59e0b;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: var(--ws-bg);
      color: #0f172a;
      line-height: 1.6;
      padding: 24px;
    }

    h1 {
      margin: 0 0 8px;
      font-weight: 700;
      letter-spacing: 0.5px;
    }

    p.subtitle {
      margin: 0 0 16px;
      color: #475569;
    }

    .wrapper {
      max-width: 960px;
      margin: 0 auto;
    }

    .card {
      background: var(--ws-card);
      border-radius: 16px;
      box-shadow: 0 14px 40px var(--ws-shadow);
      padding: 20px;
      border: 1px solid rgba(15, 23, 42, 0.06);
    }

    canvas {
      display: block;
      margin: 0 auto;
      background: radial-gradient(circle at 20% 20%, #10263f, #0a1c2f 65%, #071320);
      border-radius: 12px;
      box-shadow: inset 0 0 40px rgba(0,0,0,0.35);
    }

    .hud {
      margin-top: 14px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
      color: #0f172a;
      font-weight: 600;
    }

    .button-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    button {
      background: linear-gradient(120deg, var(--ws-accent), #5fe3ff);
      color: #0b1f33;
      border: none;
      padding: 10px 16px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      box-shadow: 0 10px 30px rgba(47,197,242,0.35);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 14px 40px rgba(47,197,242,0.45);
    }

    .note {
      color: #475569;
      font-size: 0.95rem;
      margin-top: 8px;
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>Warenschmiede Breakout (Test)</h1>
    <p class="subtitle">Nur zu Testzwecken – noch nicht offiziell verlinkt.</p>
    <p class="note">Steuerung: Links/Rechts-Tasten oder Maus, Leertaste = Spiel starten/pausieren.</p>
    <div class="card">
      <canvas id="ws-breakout-canvas" width="800" height="600"></canvas>
      <div class="hud">
        <div id="ws-hud-text">Punkte: 000000 | Level: 1 | Leben: ♥♥♥</div>
        <div class="button-row">
          <button id="ws-restart">Neu starten</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('ws-breakout-canvas');
      const ctx = canvas.getContext('2d');
      const hud = document.getElementById('ws-hud-text');
      const restartBtn = document.getElementById('ws-restart');

      const BRICK = { width: 10, height: 14, spacing: 2 };
      const LETTER_WIDTH = 5;
      const LETTER_HEIGHT = 5;
      const LETTER_SPACING = 1;
      const UNDERLINE_ROWS = 5;

      const COLORS = {
        underline: '#86c5ff',
        letter: '#1fb0e5',
        paddle: '#2cc5f2',
        ball: '#e2f6ff',
        rageBall: '#f59e0b',
      };

      const STATES = {
        READY: 'ready',
        RUNNING: 'running',
        PAUSED: 'paused',
        GAMEOVER: 'gameover',
        CLEAR: 'levelclear',
      };

      const levelDefinitions = [
        { word: 'WARENSCHMIEDE', underlineRows: UNDERLINE_ROWS },
        { word: 'KOSTENRECHNER', underlineRows: 4 },
      ];

      const letterPatterns = {
        A: [
          '01110',
          '10001',
          '11111',
          '10001',
          '10001',
        ],
        C: [
          '01110',
          '10001',
          '10000',
          '10001',
          '01110',
        ],
        D: [
          '11110',
          '10001',
          '10001',
          '10001',
          '11110',
        ],
        E: [
          '11111',
          '10000',
          '11110',
          '10000',
          '11111',
        ],
        H: [
          '10001',
          '10001',
          '11111',
          '10001',
          '10001',
        ],
        I: [
          '11111',
          '00100',
          '00100',
          '00100',
          '11111',
        ],
        K: [
          '10001',
          '10010',
          '11100',
          '10010',
          '10001',
        ],
        M: [
          '10001',
          '11011',
          '10101',
          '10001',
          '10001',
        ],
        N: [
          '10001',
          '11001',
          '10101',
          '10011',
          '10001',
        ],
        O: [
          '01110',
          '10001',
          '10001',
          '10001',
          '01110',
        ],
        R: [
          '11110',
          '10001',
          '11110',
          '10010',
          '10001',
        ],
        S: [
          '01111',
          '10000',
          '01110',
          '00001',
          '11110',
        ],
        T: [
          '11111',
          '00100',
          '00100',
          '00100',
          '00100',
        ],
        W: [
          '10001',
          '10001',
          '10101',
          '11011',
          '10001',
        ],
      };

      let state = STATES.READY;
      let score = 0;
      let lives = 3;
      let levelIndex = 0;
      let bricks = [];
      let underlineCount = 0;
      let letterCount = 0;
      let rageMode = false;
      let ragePulse = 0;

      const paddle = {
        width: 120,
        height: 14,
        x: canvas.width / 2 - 60,
        y: canvas.height - 50,
        speed: 7,
        movingLeft: false,
        movingRight: false,
      };

      const ball = {
        radius: 8,
        x: 0,
        y: 0,
        speed: 4.2,
        dx: 0,
        dy: 0,
      };

      function resetBallOnPaddle() {
        ball.x = paddle.x + paddle.width / 2;
        ball.y = paddle.y - ball.radius - 2;
        ball.dx = 0;
        ball.dy = -ball.speed;
      }

      function resetLevel(idx) {
        levelIndex = idx;
        buildLevel(levelDefinitions[levelIndex]);
        state = STATES.READY;
        resetBallOnPaddle();
        rageMode = false;
      }

      function restartGame() {
        score = 0;
        lives = 3;
        resetLevel(0);
      }

      function buildLevel(level) {
        bricks = [];
        underlineCount = 0;
        letterCount = 0;
        const totalCells = level.word.length * (LETTER_WIDTH + LETTER_SPACING) - LETTER_SPACING;
        const totalWidth = totalCells * (BRICK.width + BRICK.spacing) - BRICK.spacing;
        const startX = (canvas.width - totalWidth) / 2;
        const startY = 60;

        let offsetX = startX;
        for (const ch of level.word) {
          const pattern = letterPatterns[ch];
          if (!pattern) continue;
          for (let row = 0; row < LETTER_HEIGHT; row++) {
            for (let col = 0; col < LETTER_WIDTH; col++) {
              if (pattern[row][col] === '1') {
                const x = offsetX + col * (BRICK.width + BRICK.spacing);
                const y = startY + row * (BRICK.height + BRICK.spacing);
                bricks.push({ x, y, width: BRICK.width, height: BRICK.height, type: 'letter', destroyed: false });
                letterCount++;
              }
            }
          }
          offsetX += (LETTER_WIDTH + LETTER_SPACING) * (BRICK.width + BRICK.spacing);
        }

        const underlineWidth = offsetX - (BRICK.width + BRICK.spacing) - startX;
        const underlineStartX = startX;
        const underlineStartY = startY + LETTER_HEIGHT * (BRICK.height + BRICK.spacing) + 10;
        const underlineColumns = Math.floor((underlineWidth + BRICK.spacing) / (BRICK.width + BRICK.spacing));
        for (let row = 0; row < level.underlineRows; row++) {
          for (let col = 0; col < underlineColumns; col++) {
            const x = underlineStartX + col * (BRICK.width + BRICK.spacing);
            const y = underlineStartY + row * (BRICK.height + BRICK.spacing);
            bricks.push({ x, y, width: BRICK.width, height: BRICK.height, type: 'underline', destroyed: false });
            underlineCount++;
          }
        }
      }

      function formatLives(count) {
        return Array.from({ length: count }).map(() => '\u2665').join('');
      }

      function updateHud() {
        const displayScore = String(score).padStart(6, '0');
        hud.textContent = `Punkte: ${displayScore} | Level: ${levelIndex + 1} | Leben: ${formatLives(lives)}`;
      }

      function togglePauseOrStart() {
        if (state === STATES.READY) {
          state = STATES.RUNNING;
          if (ball.dx === 0 && ball.dy === -ball.speed) {
            ball.dx = ball.speed * (Math.random() < 0.5 ? -0.8 : 0.8);
          }
        } else if (state === STATES.RUNNING) {
          state = STATES.PAUSED;
        } else if (state === STATES.PAUSED) {
          state = STATES.RUNNING;
        } else if (state === STATES.CLEAR) {
          if (levelIndex + 1 < levelDefinitions.length) {
            resetLevel(levelIndex + 1);
          } else {
            resetLevel(0);
          }
        } else if (state === STATES.GAMEOVER) {
          restartGame();
        }
      }

      function handleKeyDown(e) {
        if (e.code === 'ArrowLeft') paddle.movingLeft = true;
        if (e.code === 'ArrowRight') paddle.movingRight = true;
        if (e.code === 'Space') {
          e.preventDefault();
          togglePauseOrStart();
        }
      }

      function handleKeyUp(e) {
        if (e.code === 'ArrowLeft') paddle.movingLeft = false;
        if (e.code === 'ArrowRight') paddle.movingRight = false;
      }

      function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const pos = e.clientX - rect.left;
        paddle.x = Math.min(Math.max(pos - paddle.width / 2, 0), canvas.width - paddle.width);
        if (state === STATES.READY) {
          resetBallOnPaddle();
        }
      }

      function updatePaddle() {
        if (paddle.movingLeft) {
          paddle.x -= paddle.speed;
        }
        if (paddle.movingRight) {
          paddle.x += paddle.speed;
        }
        paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x));
        if (state === STATES.READY) {
          resetBallOnPaddle();
        }
      }

      function reflectBallFromPaddle() {
        const hitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
        const angle = hitPos * (Math.PI / 3);
        const speed = rageMode ? ball.speed * 1.2 : ball.speed;
        ball.dx = speed * Math.sin(angle);
        ball.dy = -Math.abs(speed * Math.cos(angle));
      }

      function brickHit(brick) {
        brick.destroyed = true;
        if (brick.type === 'underline') {
          underlineCount--;
          score += 10;
        } else {
          letterCount--;
          score += rageMode ? 100 : 20;
          if (rageMode) {
            ragePulse = 8;
          }
        }

        if (!rageMode && underlineCount === 0 && letterCount > 0) {
          rageMode = true;
          ball.dx *= 1.2;
          ball.dy *= 1.2;
        }

        if (letterCount === 0 && underlineCount === 0) {
          state = STATES.CLEAR;
        }
      }

      function handleBallCollisions() {
        if (ball.x - ball.radius < 0) {
          ball.x = ball.radius;
          ball.dx *= -1;
        } else if (ball.x + ball.radius > canvas.width) {
          ball.x = canvas.width - ball.radius;
          ball.dx *= -1;
        }

        if (ball.y - ball.radius < 0) {
          ball.y = ball.radius;
          ball.dy *= -1;
        }

        if (ball.y - ball.radius > canvas.height) {
          lives -= 1;
          if (lives <= 0) {
            state = STATES.GAMEOVER;
          } else {
            state = STATES.READY;
          }
          resetBallOnPaddle();
        }

        if (ball.y + ball.radius >= paddle.y && ball.y + ball.radius <= paddle.y + paddle.height) {
          if (ball.x >= paddle.x && ball.x <= paddle.x + paddle.width && ball.dy > 0) {
            reflectBallFromPaddle();
          }
        }

        for (const brick of bricks) {
          if (brick.destroyed) continue;
          if (ball.x + ball.radius > brick.x && ball.x - ball.radius < brick.x + brick.width &&
              ball.y + ball.radius > brick.y && ball.y - ball.radius < brick.y + brick.height) {
            const overlapLeft = ball.x + ball.radius - brick.x;
            const overlapRight = brick.x + brick.width - (ball.x - ball.radius);
            const overlapTop = ball.y + ball.radius - brick.y;
            const overlapBottom = brick.y + brick.height - (ball.y - ball.radius);
            const minOverlapX = Math.min(overlapLeft, overlapRight);
            const minOverlapY = Math.min(overlapTop, overlapBottom);
            if (minOverlapX < minOverlapY) {
              ball.dx *= -1;
            } else {
              ball.dy *= -1;
            }
            brickHit(brick);
            break;
          }
        }
      }

      function updateBall() {
        if (state !== STATES.RUNNING) return;
        ball.x += ball.dx;
        ball.y += ball.dy;
        handleBallCollisions();
      }

      function drawPaddle() {
        ctx.save();
        ctx.fillStyle = COLORS.paddle;
        ctx.shadowColor = COLORS.paddle;
        ctx.shadowBlur = 16;
        ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
        ctx.restore();
      }

      function drawBall() {
        ctx.save();
        const glow = rageMode ? COLORS.rageBall : COLORS.ball;
        ctx.fillStyle = ragePulse > 0 ? COLORS.rageBall : COLORS.ball;
        ctx.shadowColor = glow;
        ctx.shadowBlur = 18;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        if (ragePulse > 0) ragePulse -= 1;
      }

      function drawBricks() {
        for (const brick of bricks) {
          if (brick.destroyed) continue;
          ctx.save();
          if (brick.type === 'underline') {
            ctx.fillStyle = COLORS.underline;
          } else {
            ctx.fillStyle = COLORS.letter;
            ctx.shadowColor = COLORS.letter;
            ctx.shadowBlur = 8;
          }
          ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
          ctx.restore();
        }
      }

      function drawStateText() {
        ctx.save();
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.font = '20px "Segoe UI", sans-serif';
        ctx.textAlign = 'center';
        if (state === STATES.READY) {
          ctx.fillText('Leertaste: Start/Pause. Pfeiltasten oder Maus zum Steuern.', canvas.width / 2, canvas.height / 2);
        } else if (state === STATES.PAUSED) {
          ctx.fillText('Pause – Leertaste zum Fortsetzen', canvas.width / 2, canvas.height / 2);
        } else if (state === STATES.GAMEOVER) {
          ctx.fillText('Game Over – Leertaste für Neustart', canvas.width / 2, canvas.height / 2);
        } else if (state === STATES.CLEAR) {
          const nextLevel = levelIndex + 1;
          const msg = nextLevel < levelDefinitions.length
            ? `Level ${levelIndex + 1} geschafft! Leertaste für Level ${nextLevel + 1}.`
            : 'Alle Level geschafft! Leertaste für Neustart.';
          ctx.fillText(msg, canvas.width / 2, canvas.height / 2);
        }
        ctx.restore();
      }

      function drawBackground() {
        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, 'rgba(25, 60, 100, 0.4)');
        gradient.addColorStop(1, 'rgba(7, 19, 32, 0.7)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      function update() {
        updatePaddle();
        updateBall();
        updateHud();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBackground();
        drawBricks();
        drawPaddle();
        drawBall();
        if (rageMode) {
          ctx.save();
          ctx.strokeStyle = 'rgba(245, 158, 11, 0.45)';
          ctx.lineWidth = 2;
          ctx.strokeRect(6, 6, canvas.width - 12, canvas.height - 12);
          ctx.restore();
        }
        drawStateText();
      }

      function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
      }

      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
      canvas.addEventListener('mousemove', handleMouseMove);
      restartBtn.addEventListener('click', restartGame);

      restartGame();
      loop();
    })();
  </script>
</body>
</html>
